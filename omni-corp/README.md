## 安装前的准备

需要安装依赖：
```
pip install -r requirements.txt
```

其中关于目标LLM的选择，目前是在服务器上的llama.cpp服务。即在Gen.py,Core/Utils.py,Core/GenData.py中的from Core.llamacpp import api as api，如果想用deepseek的api，那么就把此条注释掉，替换为import Core.deepseek as api即可。

当前使用的llama.cpp跑的模型是qwen2.5-coder-7b-fp16。

## 运行

运行Gen.py，针对目标C工程，生成15个libfuzzer代码

```
python Gen.py -i /source/project/path -o /output/path
```
输入为目标工程文件夹
输出为存放生成的harness目录

## 目前进度


当前已经完成框架搭建。现在已经能够完成对中小型C源码进行目标函数筛选，并生成libfuzzer code。

对于C工程，能够找出工程中适合作为libfuzzer的目标函数，然后根据这些函数生成Libfuzzer。

对于C++工程，当前仍在开发阶段，目前纠结于是否需要有函数筛选这个过程。C++工程的功能实现，本质上就是对类的调用。对于具体调用了哪些函数，本身并不重要，当前也是在这个基础上进行开发。

由于LLM本身是概率性的，那么这个项目的核心在于控制传递概率。也就是说，尽可能减少环节，并通过一定方法保证每个环节的正确率。

对于筛选-生成两个环节来说。一旦筛选过程出现漏报，那么对生成会造成非常严重的影响。因此需要尽可能的保证筛选过程的正确率。

保证正确率，主要有两个手段，1是保证单次生成的准确性。2是通过多次生成保证结果正确性。对于单次生成准确性，可以采用对大语言模型进行微调的方式实现。对于多次生成保证正确性，最简单的方法是一个Prompt多次生成，采用统计的方法来选择最佳答案。但是由于LLM本身参数设置问题，单个Prompt多次运行很可能会由于过拟合得到相同的结果。因此所谓的多次运行，就需要根据fuzz driver的特点采用不同的prompt实现对函数的筛选。

现在已经完成对C工程的筛选和生成，由于时间和精力的关系，现在没有通过脚本直接对目标代码进行编译筛选，也没有将输出的Prompt中的harness提取出来，prompt本身也需要优化，例如头文件的位置等信息并没有放入到prompt中。这个需要后续进一步优化。


## 2024年11月14日 TODO

对于INT_EQ这种类型的测试辅助函数需要编写prompt进行排除。

测试对象的类型尽可能选择文件处理类的project，协议、驱动和系统类的暂时不考虑。后续需要考虑GUI中的输入处理函数。

1.3.1 中的程序中，可能存在输入在结构体中的情况，需要进行处理。

