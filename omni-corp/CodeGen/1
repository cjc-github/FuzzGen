[{"name": "qoi_decode", "type": "function", "body": "void *qoi_decode(const void *data, int size, qoi_desc *desc, int channels) {\n\tconst unsigned char *bytes;\n\tunsigned int header_magic;\n\tunsigned char *pixels;\n\tqoi_rgba_t index[64];\n\tqoi_rgba_t px;\n\tint px_len, chunks_len, px_pos;\n\tint p = 0, run = 0;\n\n\tif (\n\t\tdata == NULL || desc == NULL ||\n\t\t(channels != 0 && channels != 3 && channels != 4) ||\n\t\tsize < QOI_HEADER_SIZE + (int)sizeof(qoi_padding)\n\t) {\n\t\treturn NULL;\n\t}\n\n\tbytes = (const unsigned char *)data;\n\n\theader_magic = qoi_read_32(bytes, &p);\n\tdesc->width = qoi_read_32(bytes, &p);\n\tdesc->height = qoi_read_32(bytes, &p);\n\tdesc->channels = bytes[p++];\n\tdesc->colorspace = bytes[p++];\n\n\tif (\n\t\tdesc->width == 0 || desc->height == 0 ||\n\t\tdesc->channels < 3 || desc->channels > 4 ||\n\t\tdesc->colorspace > 1 ||\n\t\theader_magic != QOI_MAGIC ||\n\t\tdesc->height >= QOI_PIXELS_MAX / desc->width\n\t) {\n\t\treturn NULL;\n\t}\n\n\tif (channels == 0) {\n\t\tchannels = desc->channels;\n\t}\n\n\tpx_len = desc->width * desc->height * channels;\n\tpixels = (unsigned char *) QOI_MALLOC(px_len);\n\tif (!pixels) {\n\t\treturn NULL;\n\t}\n\n\tQOI_ZEROARR(index);\n\tpx.rgba.r = 0;\n\tpx.rgba.g = 0;\n\tpx.rgba.b = 0;\n\tpx.rgba.a = 255;\n\n\tchunks_len = size - (int)sizeof(qoi_padding);\n\tfor (px_pos = 0; px_pos < px_len; px_pos += channels) {\n\t\tif (run > 0) {\n\t\t\trun--;\n\t\t}\n\t\telse if (p < chunks_len) {\n\t\t\tint b1 = bytes[p++];\n\n\t\t\tif (b1 == QOI_OP_RGB) {\n\t\t\t\tpx.rgba.r = bytes[p++];\n\t\t\t\tpx.rgba.g = bytes[p++];\n\t\t\t\tpx.rgba.b = bytes[p++];\n\t\t\t}\n\t\t\telse if (b1 == QOI_OP_RGBA) {\n\t\t\t\tpx.rgba.r = bytes[p++];\n\t\t\t\tpx.rgba.g = bytes[p++];\n\t\t\t\tpx.rgba.b = bytes[p++];\n\t\t\t\tpx.rgba.a = bytes[p++];\n\t\t\t}\n\t\t\telse if ((b1 & QOI_MASK_2) == QOI_OP_INDEX) {\n\t\t\t\tpx = index[b1];\n\t\t\t}\n\t\t\telse if ((b1 & QOI_MASK_2) == QOI_OP_DIFF) {\n\t\t\t\tpx.rgba.r += ((b1 >> 4) & 0x03) - 2;\n\t\t\t\tpx.rgba.g += ((b1 >> 2) & 0x03) - 2;\n\t\t\t\tpx.rgba.b += ( b1       & 0x03) - 2;\n\t\t\t}\n\t\t\telse if ((b1 & QOI_MASK_2) == QOI_OP_LUMA) {\n\t\t\t\tint b2 = bytes[p++];\n\t\t\t\tint vg = (b1 & 0x3f) - 32;\n\t\t\t\tpx.rgba.r += vg - 8 + ((b2 >> 4) & 0x0f);\n\t\t\t\tpx.rgba.g += vg;\n\t\t\t\tpx.rgba.b += vg - 8 +  (b2       & 0x0f);\n\t\t\t}\n\t\t\telse if ((b1 & QOI_MASK_2) == QOI_OP_RUN) {\n\t\t\t\trun = (b1 & 0x3f);\n\t\t\t}\n\n\t\t\tindex[QOI_COLOR_HASH(px) % 64] = px;\n\t\t}\n\n\t\tpixels[px_pos + 0] = px.rgba.r;\n\t\tpixels[px_pos + 1] = px.rgba.g;\n\t\tpixels[px_pos + 2] = px.rgba.b;\n\t\t\n\t\tif (channels == 4) {\n\t\t\tpixels[px_pos + 3] = px.rgba.a;\n\t\t}\n\t}\n\n\treturn pixels;\n}", "class": [], "include": "", "contain": "/qoi.h", "readme": "", "parm": [{"name": "qoi_desc", "type": "parm", "body": "typedef struct {\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned char channels;\n\tunsigned char colorspace;\n} qoi_desc;", "class": []}], "return": "", "call_list": [{"name": "QOI_MALLOC", "type": "call", "class": []}, {"name": "QOI_COLOR_HASH", "type": "call", "class": []}, {"name": "qoi_read_32", "type": "call", "class": []}, {"name": "QOI_ZEROARR", "type": "call", "class": []}]}]